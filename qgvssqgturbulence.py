# -*- coding: utf-8 -*-
"""QGvsSQGturbulence.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1arQ41tTeiTERwvrvNL1Vu08BCKVwWFb0

# Kinetic energy spectrum in the interior QG vs SQG turbulence
QG: Quasi-Geostrophic
SQG = 
Let's simulate the behavior of freely decaying ocean turbulence in the QG and SQG models and evaluate the fundamental difference in the partitioning of energy between different spatial scales of motion. 

Specifically, let's compare the power-law exponents in the scaling of the kinetic energy spectrum with the wavenumber that develops in the inertial range.

### Summarized Answers

####SQG model

**(a) Write down the SQG equations in spectral space.**

Photo is missing in this file. Essentially, we have a psi_tilde = b_tile / (N |k vector|)

**(b) From the numerical implementation perspective, what are the similarities and differences between interior QG adn SQG equations?**

From a numerical implementation perspective, we see that both the interior QG and SQG models start with random conditions and establish order over time. In the SQG, we see that eddies eventually dissipate. In the QG, we see a pattern of propagation to the left and that blobs of vorticity form.

**(c) Write down the code to solve the SQG equations by modifying your previously written single-layer QG code.**

See code below.

####KE Spectrum

**(d) Given a 2D velocity field (u,v) defined in (x,y) space, write a function that computes the kinetic energy spectrum. Note: in a simplified case where there is no significant anisotropy present in the flow field, one can simply take a 1D FFT along the x-axis, calculate its absolute magnitude squared, and then average along the y-axis.**


```
def calc_KE(q_field, time_index):
  q_hat = np.fft.fft2(q_store[:,:,150])
  # psi_hat = -q_hat / ((k**2 + l**2)+(1/Ld**2)) # for QG equations
  psi_hat = q_hat/(np.abs(K)*N) # for SQG equations
  u = np.fft.ifft2(-1j*l*psi_hat)
  v = np.fft.ifft2(1j*k*psi_hat)
  du_qhat = np.fft.fft2(u*q)
  dv_qhat = np.fft.fft2(v*q)
  v_hat = np.fft.fft2(v)
  u_hat = np.fft.fft2(u)
      
  abs_sq_uhat = np.abs(np.square(u_hat))
  abs_sq_vhat = np.abs(np.square(v_hat))

  k_range = np.concatenate((np.arange(0, nx // 2 + 1), np.arange(-nx // 2 + 1, 0))) * k0x

  KE_array = np.mean(abs_sq_uhat, axis=1) + np.mean(abs_sq_vhat, axis=1)
  KE_array[k_range <= 0] = np.nan
  KE_array = KE_qg[~KE_array.isnan(KE_array)]
  return KE_array
```

#### Interior QG vs SQG simulations
**(e) Initialize the QG and SQG simulations with random in space initial conditions for potential vorticity (QG) and surface buoyancy (SQG) and run the simulations until the initial conditions change dramatically due to eddy-eddy interactions.**

See code and gifs below. 

**(f) Describe the major differences and similarities of eddy field evolution in both models.**

Compareing the energy at high wave numbers, there is higher energy in SQG. In QG, we do not see a decay away from the boundaries. In SQG, we see a decay away from the boundary. This tells us useful information about the frequency of observations wee need to observe an eddy and shows that this decomposition is justified. We can observe situations that are dominated by QG or dominated by SQG, which can influence how we tackle the problem. For example, QG obviously does not explain eddies as we don't see coherence but Rossby waves are preserved in the lienar sense, and the difference starts at dissipation. To see the differences, please refer to the the gifs.

####Power-law exponent in the inertial range of the KE spectrum
**(g) Plot the KE spectra for both simulations on a log-log plot and identify the power law exponents in the corresponding inertial ranges. How do the power law exponents compare between the QG and SQG models?**

See the plots below. The exponent in the QG model is around -3 and the exponent in the SQG model is around -1.6 (which is what we expect). The exponent is more negative in the QG model meaning that it is steeper. 

**(h) Which of the two models leads to a shallower spectrum and what does it imply for the existence of energetic smaller-scale features?**

The SQG model leads to a shallower spectrum, and this implies the existence of smaller scale features like eddies.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation  #creating animations and videos.
from IPython.display import Video, HTML, Image  #embedding videos in the notebook
from scipy.stats import linregress

# Define numerical constants and the domain dimensions (Square box of 1000x1000 km)
L = 1000e3
W = 1000e3

nx = 128
ny = 128

dx = L / nx
dy = W / ny

# Use the number of grid boxes that are powers of 2 to speed up the Fourier transform.
[x,y]=np.meshgrid(np.arange(1/2,nx,1)/nx*L-L/2,np.arange(1/2,ny,1)/ny*W-W/2);

# FFT function outputs the transformed 2D array with the zonal and meridional wavevectors k, l:
k0x=2*np.pi/L 
k0y=2*np.pi/W

k_range = np.concatenate((np.arange(0, nx // 2 + 1), np.arange(-nx // 2 + 1, 0))) * k0x
l_range = np.concatenate((np.arange(0, ny // 2 + 1), np.arange(-ny // 2 + 1, 0))) * k0y

[k, l] = np.meshgrid(k_range, l_range)
# Define the magnitude of the wave number as K and plot it as a 2D image with k,l being the axis
K = np.sqrt(k**2 + l**2)

# Filter out scales of motion that approach the grid box size. 
cphi = 0.69 * np.pi
wvx = np.sqrt(K**2) * dx

z = -18 * (wvx - cphi)**7
z_clipped = np.clip(z, -700, 700)  # Clip the values to avoid overflow

filtr = np.exp(z_clipped) * (wvx > cphi) + (wvx <= cphi)

filtr[np.isnan(filtr)] = 1

"""## QG model"""

# To explore the Rossby wave propagation, define ICs for PV with an example wave package as:
f0 = 1e-4
Ld = 40e3
b = 1.6e-11

q_store = np.zeros([nx, ny, 201])
q0 = (np.random.rand(nx, ny) - 0.5) * 1e-6
q = q0
q_hat = np.fft.fft2(q)

dt = 4 * 60 * 60  # 4 hours

for j in range(1, 20001):
    psi_hat = -q_hat / ((k ** 2 + l ** 2) + (1 / Ld ** 2))

    u = np.real(np.fft.ifft2(-1j * l * psi_hat))
    v = np.real(np.fft.ifft2(1j * k * psi_hat))

    u_hat = np.fft.fft(u, axis=1)
    v_hat = np.fft.fft(v, axis=1)

    uke = np.abs(u_hat) ** 2
    vke = np.abs(v_hat) ** 2
    ke_total = np.mean(uke, axis=1) + np.mean(vke, axis=1)

    duq_hat = np.fft.fft2(u * q)
    dvq_hat = np.fft.fft2(v * q)

    dqdt_hat = -1j * k * duq_hat - 1j * l * dvq_hat - b * 1j * k_range * psi_hat

    if j == 1:
        dqdt_hat_prev = dqdt_hat

    q_hat = q_hat + 1.5 * dt * dqdt_hat + 0.5 * dqdt_hat_prev
    q_hat = q_hat * filtr

    q = np.real(np.fft.ifft2(q_hat))

    dqdt_hat_prev = dqdt_hat

    if j % 100 == 0:
        q_store[:, :, j // 100] = q

def animation_func(i):
    fig.clear()
    plt.imshow(q_store[:,:,i])
    plt.axis('off')

fig = plt.figure(figsize=(10,4))
animation = FuncAnimation(fig, animation_func, frames = 200)

animation.save('gfd2_QGmodel.gif') 
plt.close()
Image('gfd2_QGmodel.gif')

# KE Spectra QG
q_hat = np.fft.fft2(q_store[:,:,150])
psi_hat = -q_hat / ((k**2 + l**2)+(1/Ld**2))
u = np.fft.ifft2(-1j*l*psi_hat)
v = np.fft.ifft2(1j*k*psi_hat)
du_qhat = np.fft.fft2(u*q)
dv_qhat = np.fft.fft2(v*q)
v_hat = np.fft.fft2(v)
u_hat = np.fft.fft2(u)
    
abs_sq_uhat = np.abs(np.square(u_hat))
abs_sq_vhat = np.abs(np.square(v_hat))

# we already defined this earlier
k_range = np.concatenate((np.arange(0, nx // 2 + 1), np.arange(-nx // 2 + 1, 0))) * k0x

KE_qg = np.mean(abs_sq_uhat, axis=1) + np.mean(abs_sq_vhat, axis=1)
KE_qg[k_range <= 0] = np.nan
KE_qg = KE_qg[~np.isnan(KE_qg)]

# Given data points (x, y)
x = np.arange(6,46)  # x-values
y = KE_qg[5:45]  # y-values
# Filter out invalid data points (x or y <= 0)
valid_indices = np.where((x > 0) & (y > 0))
x_valid = x[valid_indices]
y_valid = y[valid_indices]
# Take the logarithm of both x and y
log_x = np.log10(x)
log_y = np.log10(y)

# Perform linear regression on the transformed data
slope, intercept, r_value, p_value, std_err = linregress(log_x, log_y)

# Extract the power law exponent
power_exponent = slope

# Print the power law exponent
print("Power Law Exponent:", power_exponent)

x = np.arange(0,100)  # larger range for plotting purposes x-values
log_x = np.log10(x)

plt.title('QG KE Spectrum')
plt.plot(np.arange(len(KE_qg)), KE_qg)
plt.plot(x, 10**(intercept + slope*log_x), 'r-', label='Fit: b={:.2f}'.format(power_exponent))
plt.xscale('log')
plt.yscale('log')
plt.xlabel('log k')
plt.xlabel('log of kinetic energy')
plt.show()

"""## SQG model"""

# Implement the time-stepping loop to obtain the evolution of the PV 
# in spectral space. use the time step dt = 1 hrs
dt = 1*60*60 # hours

b = np.random.rand(nx, ny)
b = b - np.mean(b)
b = 0.001*b # this affects how it is

b_hat = np.fft.fft2(b)

K = np.sqrt(k**2 + l**2)
N = 0.01

def compute_d_dtb_hat(b):
    b_hat = np.fft.fft2(b)
    psi_hat = b_hat/(np.abs(K)*N)
    psi_hat[K == 0] = 0 
    u = np.real(np.fft.ifft2(-1j*l*psi_hat))
    v = np.real(np.fft.ifft2(1j*k*psi_hat))
    du_bhat = np.fft.fft2(u*b)
    dv_bhat = np.fft.fft2(v*b)
    v_hat = np.fft.fft2(v)
    d_dtb_hat = -(1j*k*du_bhat + 1j*l*dv_bhat)
    return d_dtb_hat

b_store = np.zeros((40000,128,128))

for timestep in range(40000):
    present_dbdt=compute_d_dtb_hat(b)

    if timestep==0:
        past_dbdt=present_dbdt
    b_hat =(b_hat + 1.5*dt*present_dbdt - 0.5*dt*past_dbdt)*filtr
    b = np.real(np.fft.ifft2(b_hat))
    b_store[timestep,:,:] = b
    past_dbdt=present_dbdt

def animation_func(i):
    fig.clear()
    plt.imshow(b_store[800*i,:,:])
    plt.axis('off')

fig = plt.figure(figsize=(10,4))
animation = FuncAnimation(fig, animation_func, frames = 50)

animation.save('gfd2_SQGmodel.gif') 
plt.close()
Image('gfd2_SQGmodel.gif')

# KE Spectra SQG
b_hat = np.fft.fft2(b_store[20000,:,:])
psi_hat = b_hat/(np.abs(K)*N)

psi_hat[K == 0] = 0 

u = np.real(np.fft.ifft2(-1j*l*psi_hat))
v = np.real(np.fft.ifft2(1j*k*psi_hat))

u_hat = np.fft.fft(u,axis=0)
v_hat = np.fft.fft(v,axis=0)

abs_sq_uhat = np.abs(np.square(u_hat))
abs_sq_vhat = np.abs(np.square(v_hat))

# we already defined this earlier
k_range = np.concatenate((np.arange(0, nx // 2 + 1), np.arange(-nx // 2 + 1, 0))) * k0x

KE = np.mean(abs_sq_uhat, axis=1) + np.mean(abs_sq_vhat, axis=1)
KE[k_range <= 0] = np.nan
KE = KE[~np.isnan(KE)]

# Given data points (x, y)
x = np.arange(1,51)  # x-values
y = KE[:50]  # y-values
# Filter out invalid data points (x or y <= 0)
valid_indices = np.where((x > 0) & (y > 0))
x_valid = x[valid_indices]
y_valid = y[valid_indices]
# Take the logarithm of both x and y
log_x = np.log10(x)
log_y = np.log10(y)

# Perform linear regression on the transformed data
slope, intercept, r_value, p_value, std_err = linregress(log_x, log_y)

# Extract the power law exponent
power_exponent = slope

# Print the power law exponent
print("Power Law Exponent:", power_exponent)

x = np.arange(0,100)  # larger range for plotting purposes x-values
log_x = np.log10(x)

plt.title('SQG KE Spectrum')
plt.plot(np.arange(len(KE)), KE)
plt.plot(x, 10**(intercept + slope*log_x), 'r-', label='Fit: b={:.2f}'.format(power_exponent))
plt.xscale('log')
plt.yscale('log')
plt.xlabel('log k')
plt.xlabel('log of kinetic energy')
plt.show()

